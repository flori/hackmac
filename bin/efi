#!/usr/bin/env ruby
#
# Hackmac EFI Management Tool
#
# This script provides comprehensive management capabilities for OpenCore EFI
# partitions including mounting/unmounting, cloning, kext management, OpenCore
# upgrades, and git operations.
#
# Features:
#
# - Mount/Unmount EFI partitions
# - Clone EFI partitions between devices
# - Manage kernel extensions (kexts) and their versions
# - Upgrade OpenCore bootloader to latest versions
# - Validate OpenCore configurations
# - Git integration for tracking EFI changes
#
# Usage: efi [command] [arguments]
# Run without arguments to see full help and available commands
#
# Configuration:
# Set HACKMAC_CONFIG to specify a custom config file path
# Defaults to ~/.config/hackmac/hackmac.yml

require 'hackmac'
include Hackmac
include Utils

# The clone method performs a disk cloning operation between two volumes
#
# This method facilitates the cloning of data from one disk volume to another
# by first prompting the user for confirmation, then mounting both volumes,
# performing a dry-run of the rsync operation to show what would be copied, and
# finally executing the actual copy with deletion of extraneous files.
#
# @param from [ String ] the source disk identifier to clone from
# @param to [ String ] the target disk identifier to clone to
# @return [ void ] Returns nothing but performs system disk cloning operations
def clone(from:, to:)
  ask("Cloning from #{from} to #{to} now? (y/n) ") or return
  x %{sudo mkdir -v "/Volumes/#{from}"}
  x %{sudo mkdir -v "/Volumes/#{to}"}
  x %{sudo diskutil mount -mountPoint "/Volumes/#{from}" "#{from}"}
  x %{sudo diskutil mount -mountPoint "/Volumes/#{to}" "#{to}"}
  x %{rsync -nav --exclude ".*" --delete "/Volumes/#{from}/" "/Volumes/#{to}/"}
  unless ask("This will be copied/deleted. Really do it? (y/n) ")
    puts " *** Interrupted.".bold.yellow
    exit 1
  end
  x %{rsync -av --exclude ".*" --delete "/Volumes/#{from}/" "/Volumes/#{to}/"}
end

# The usage method displays help information and command usage instructions
#
# This method outputs a formatted help message that describes the available
# commands and their arguments for the Hackmac tool. It provides default device
# names
# and explains how to configure the tool using environment variables.
#
# @return [ void ] Returns nothing but prints usage information to standard output
def usage
  default_dev = device_name('main')

  puts <<~EOT

    Usage #{File.basename($0)} [command] [arguments]

    Set HACKMAC_CONFIG to the config file, e. g. ~/.config/hackmac/foobar.yml

    Commands are

      help        this help

      mount       EFI partition

        argument DEVICE (defaults to #{default_dev})

      unmount     EFI partition

        argument DEVICE (defaults to #{default_dev})

      clone       clone EFI partitions

        argument FROM_DEVICE (defaults to #{default_dev})

        argument TO_DEVICE (defaults to #{default_dev})

        The devices have to be different.

      kext        list version info of kext

        argument PATH to the kext

      kext_upgrade

        argument PATH to the kext

        argument FORCE == 'force' => always upgrade

      kexts       list kexts versions by clover

        argument DEVICE (defaults to #{default_dev})

        The EFI partion on DEVICE is used to find the clover kexts in
        subdirectory /Other.

      oc          shows currently booted OpenCore version

      oc_upgrade EFI partition

                 Upgrade OpenCore on this partition to newest version

      oc_validate EFI partition

                  validates config.plist in the given EFI

      diff        EFI partition

        argument DEVICE (defaults to #{default_dev})

        Shows changes as a diff with git, passes arguments to diff command
        after "--".

      commit      EFI partition

        argument DEVICE (defaults to #{default_dev})

        Commits changes with git, passes arguments to commit command
        after "--".

  EOT
end

# The device_name method determines the appropriate device name based on the
# provided mount device identifier
#
# This method retrieves the device name by checking if a mount device
# identifier is provided. If no identifier is given, it returns the main device
# name from the configuration. If an identifier is provided, it looks up the
# corresponding device in the configuration and returns its name, falling back
# to the original identifier if not found
#
# @param mdev [ String, nil ] the mount device identifier to look up, or nil to use the main device
#
# @return [ String ] the resolved device name from configuration or the original identifier
def device_name(mdev)
  case mdev
  when nil
    $config.devices.main.name
  else
    if n = $config.devices[mdev]&.name
      n
    else
      mdev
    end
  end
end

# The git_args method processes command line arguments to determine the device
# name and default git arguments
#
# This method handles the parsing of command line arguments for git operations,
# identifying whether a device name is provided and managing the default
# arguments that should be used when none are specified
#
# @param default [ Array<String> ] the default git arguments to use when none are provided
#
# @return [ String ] the device name determined from the command line arguments
def git_args(default:)
  mdev =
    if ARGV.first == '--'
      ARGV.shift
      device_name(nil)
    else
      device_name(ARGV.shift)
    end
  if ARGV.empty?
    ARGV.unshift(*default)
  end
  mdev
end

$config = Hackmac::Config.load

bold_head = -> h { h.sub(/\A[a-z]/) { $&.upcase }.bold }

case command = ARGV.shift
when 'help', nil
  usage
when 'mount'
  mdev = device_name(ARGV.shift)
  x %{sudo diskutil mount "#{mdev}"}
when /\Aun?mount\z/
  mdev = device_name(ARGV.shift)
  x %{sudo diskutil unmount "#{mdev}"}
when /\Adiff\z/
  mdev = git_args(default: %w[ --color --stat --cached ])
  x %{sudo diskutil mount "#{mdev}"}
  cd "/Volumes/#{mdev}" do
    x %{git add -A}
    x %{git diff #{Shellwords.join(ARGV)}}
  end
when /\Acommit\z/
  mdev = git_args(default: %w[ -v ])
  x %{sudo diskutil mount "#{mdev}"}
  cd "/Volumes/#{mdev}" do
    x %{git add -A}
    system %{git commit #{Shellwords.join(ARGV)}} and
      x %{ git push }
  end
when 'clone'
  from = ARGV.shift or fail "need from argument"
  from = device_name(from)
  to = ARGV.shift or fail "need to argument"
  to = device_name(to)
  from != to or fail "cloning only allowed from one partition to another"
  clone from: from, to: to
when 'kexts'
  mdev = device_name(ARGV.shift)
  x %{sudo diskutil mount "#{mdev}"}
  on_efi = Dir["/Volumes/#{mdev}/#{$config.kext.efi_path}/*.kext"].map do |path|
    Kext.new(path: path, config: $config)
  rescue Errno::ENOENT
    warn  "#{path.to_s.inspect} has no info => Skipping."
  end.compact.sort_by(&:name)
  puts 'EFI'.yellow.bold + " (#{mdev})".bold
  puts Tabulo::Table.new(on_efi, align_header: :left, border: :modern) { |t|
    t.add_column(:name, header_styler: bold_head)
    t.add_column(
      :itself,
      header: 'Version/Remote',
      styler: -> v, s { v.version < v.remote_version ? s.red : s.green rescue s.yellow },
      formatter: -> e { "%s %s %s" % [ e.version, ({ 0 => ?=, -1 => ?<, 1 => ?> }[e.version <=> e.remote_version] rescue nil), e.remote_version ] },
      header_styler: bold_head
    )
    t.add_column(:path, header_styler: bold_head)
  }.pack
when 'kext'
  path = ARGV.shift or fail 'need kext dir'
  path = Pathname.new(path).expand_path.to_s
  puts Kext.new(path: path)
when 'kext_upgrade'
  path  = ARGV.shift or fail 'need kext dir'
  path = Pathname.new(path).expand_path.to_s
  force = ARGV.shift == 'force'
  Hackmac::KextUpgrader.new(path: path, config: $config, force: force).perform
when 'oc'
  x %{nvram 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:opencore-version}
when 'oc_remote'
  puts OC.new(config: $config)
when 'oc_upgrade'
  mdev = device_name(ARGV.shift)
  ocu = OCUpgrader.new(mdev: mdev, config: $config)
  ocu.perform
when 'oc_validate'
  mdev = device_name(ARGV.shift)
  ocv = OCValidator.new(mdev: mdev, config: $config)
  ocv.perform or exit 1
else
  fail "don't know how to #{command}"
end
